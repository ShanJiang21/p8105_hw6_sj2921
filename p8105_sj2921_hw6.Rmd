---
title: "p8105_hw6_sj2921"
author: "Shan Jiang"
date: "11/16/2018"
output: github_document
---
## problem 1
```{r}
library(tidyverse)
library(broom)
library(Hmisc)
library(modelr)
library(mgcv)
```

```{r}
### Import the raw data.

homicide_raw = read_csv("https://raw.githubusercontent.com/washingtonpost/data-homicides/master/homicide-data.csv")
```

### 1.1 Tidy the dataset

```{r}
homicide_df = homicide_raw %>% 
  mutate(city_state = str_c(city, state, sep = "," )) %>% 
  mutate(case_status = as.numeric(disposition == "Closed by arrest")) %>% 
  filter(!city_state %in% c("Dallas,TX", "Phoenix,AZ","Kansas City,MO","Tulsa,AL" )) %>%
   ### relevel `victim_race`
  mutate(victim_race = 
           fct_relevel(ifelse(victim_race == "White", "white", "non-white"), "white")) %>% 
  ## change the victim_age as numeric
  mutate(victim_age = as.numeric(victim_age)) 
  
```

Since there are three levels for the factor of disposition, we need to recode it as whether the homicide is solved or not: for *Closed by arrest*, we coined it as 0 while  adding 1 for "*Open/No arrest*" or "*closed without arrest*".

For categories white and non-white, with white as the reference category. 


### 1.2 Simulation

(1)  Baltimore, MD Models 
For the city of Baltimore, MD, use the `glm` function to fit a logistic regression with resolved vs unresolved as the outcome and victim age, race(as just classified) and sex as predictors. 

```{r}
Bal_logit = 
  homicide_df %>% 
  filter(city_state == "Baltimore,MD") %>% 
  glm(case_status ~ victim_age  + victim_sex + victim_race , data = ., family = binomial) 

## Obtain the estimate and confidence interval of the adjusted odds ratio for solving homicides comparing non-white victims to white victims keeping all other variables fixed.
Bal_logit %>% 
  broom::tidy() %>% 
  mutate(OR = exp(estimate)) %>%  ## sig.level = 0.05, critical value = 1.96
  mutate(CI.lower =  exp(estimate - std.error * 1.96)) %>% 
  mutate(CI.higher =  exp(estimate + std.error * 1.96)) %>%
  select(term, log_OR = estimate, OR, CI.lower, CI.higher, p.value) %>% 
  knitr::kable(digits = 3)
```

*Comment*: the estimator of odds ratio is 0.441 < 1 (95% CI: [0.313, 0.620]), implying that in Baltimore city, the odds of being murdered is 0.441 times lower among non-white citizens than white. Because the odds ratio is under 1, which means being non-white can exert protective effect for avoiding being murdered.  


## Each city:Compare the white and non-white values 

Do this within a “tidy” pipeline, making use of `purrr::map`, `list columns`, and unnest as necessary to create a dataframe with estimated ORs and CIs for each city.

```{r}
## Create a list column for the city_state dataset

homicide_nest = homicide_df %>% 
  group_by(city_state) %>% 
  nest(victim_race:case_status)

head(homicide_nest)

## Create a glm function 
homicide_glm  = function(df) {
  glm = glm(case_status ~ victim_age + victim_race + victim_sex, data = df, family = binomial()) %>% 
  broom::tidy() 
  
  glm 
}


## Apply to each city, state 

city_murder =  homicide_nest %>% 
    mutate(models = map(homicide_nest$data, homicide_glm )) %>% 
    select(-data) %>% 
    unnest() 

## Add CI, city and tidy 
city_murder = city_murder %>%  
        mutate(OR = exp(estimate),
               log_OR = estimate) %>%
        filter(term == "victim_racenon-white") %>% 
        mutate(CI.low =  exp(estimate - std.error * 1.96) ) %>% 
        mutate(CI.high =  exp(estimate + std.error * 1.96)) %>% 
        select(city_state, term, log_OR, OR, p.value, CI.low, CI.high) %>% 
        mutate(city_state = fct_reorder(city_state, OR)) 
  
```

## Plot 

Create a plot that shows the estimated ORs and CIs for each city. Organize cities according to estimated OR, and comment on the plot.

```{r out.width = "70%", fig.height = 7, fig.align = "center"}
city_murder %>% 
  ggplot(aes(x = city_state, y = OR)) + 
  geom_point(alpha = 0.52) +
  geom_errorbar(mapping = aes(ymin = CI.low, ymax = CI.high, colour = "darkred" )) +
  theme_bw() +
  theme(legend.position = "none",
        legend.direction = "horizontal",
         legend.key.size = unit(0.06, "cm")) + 
  coord_flip() + 
      labs(x = "City State",
           y = "City Homicide Odds ratio", 
           title = "Homicide Odds ratio of race white vs. Non-white by City, state", 
           subtitle = "Error Bar Using mean as center with Confidence Intervals", 
           caption = "source: Washington Post") 

```


## Problem 2

### Importation and cleaning the data 
```{r}
birth_weight = read_csv("./Data/birthweight.csv") 
  

birth_weight = birth_weight %>% 
    janitor::clean_names() %>% 
    mutate(babysex = as.factor(babysex),
           malform = as.factor(malform),
           mrace = as.factor(mrace),
           frace = as.factor(frace)) %>% 
    mutate(bhead = as.numeric(bhead), 
            bwt = as.numeric(bwt),
            mheight = as.numeric(mheight),
            mheight = as.numeric(mheight)) 

# no missing data
skimr::skim(birth_weight )

```

```{r}
##
summary(birth_weight$pnumlbw )

```

* There are `nrow(birth_weight)` observations and `ncol(birth_weight)` variables in the dataset. There are 4 factors as babysex, presence of malformations, mother and father's race. Remaining variables are of numeric format.

* There are 2 variables containing many 0 as their observation value: `pnumlbw ` and `pnumsga` in the birth weight data.


2. Model procedure: stepwise elimination 


```{r}
## Exploration of correlation for numeric variables in dataset.
correlation_df = birth_weight %>%
  select(-babysex, -frace, -mrace, -malform) %>% 
  cor(.[3], .) %>% 
  broom::tidy() %>% 
  select(-.rownames, -bwt) 

correlation_df %>% 
  knitr::kable()
```

Start with a full regression model for birthweight.

```{r}
## Stepwise 
full_mlr = lm(bwt ~ ., data = birth_weight )





## Cross Validation 
set.seed(1)

cv_df = crossv_mc(birth_weight, 100) 

## Train data sets and test data sets
cv_df %>% 
  pull(train) %>% 
  .[[1]] %>% 
  as_tibble
cv_df %>% 
  pull(test) %>% 
  .[[1]] %>% 
  as_tibble


cv_df =
  cv_df %>% 
  mutate(train = map(train, as_tibble),
         test = map(test, as_tibble))

cv_df = 
  cv_df %>% 
  mutate(lin_mod1    = map(train, ~lm(bwt ~ babysex + fincome + gaweeks + parity + smoken + wtgain, , data = .x)),
         lin_ = map(train, ~lm( , data = .x)),
         lin_comb = map(train, ~lm(bwt ~ babysex + fincome + gaweeks + parity + smoken + wtgain data = .x))) %>% 
  mutate(rmse_lin    = map2_dbl(lin_mod, test, ~rmse(model = .x, data = .y)),
         rmse_nonlin = map2_dbl(nonlin_mod, test, ~rmse(model = .x, data = .y)),
         rmse_wiggly = map2_dbl(wiggly_mod, test, ~rmse(model = .x, data = .y)))


lin_mod = lm(y ~ x, data = birth_weight)
birth_weight %>% 
ggplot(aes(x = fincome, y =  bwt )) + 
       geom_point() + 
       theme_bw()




```

3. fit a model and plot
```{r}
birth_weight %>%  
  ggplot(aes(x = blength , y = bwt )) + 
  geom_point(alpha = .5)
```


